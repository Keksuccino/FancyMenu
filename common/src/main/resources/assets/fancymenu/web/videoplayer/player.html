<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FancyMenu Video Player</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        body, html {
            width: 100%;
            height: 100%;
            background-color: #000000;
        }

        #videoContainer {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        video {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        /* Explicitly hide any video controls immediately */
        video::-webkit-media-controls,
        video::-webkit-media-controls-enclosure,
        video::-webkit-media-controls-panel,
        video::-webkit-media-controls-panel-container,
        video::-webkit-media-controls-play-button,
        video::-webkit-media-controls-overlay-play-button {
            display: none !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* When fillScreen is enabled */
        .fill-screen video {
            object-fit: cover;
            width: 100%;
            height: 100%;
        }
        
        /* Hide the loader completely */
        #loader {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .spinner {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="videoContainer">
        <video id="videoPlayer" playsinline webkit-playsinline controlslist="nodownload nofullscreen noremoteplayback" nocontrols></video>
    </div>
    
    <!-- Loader is hidden but kept in DOM for JS functionality -->
    <div id="loader" style="display:none !important;">
        <div class="spinner"></div>
        <div id="loaderText"></div>
    </div>

    <script>
        // Debug mode flag - set to false to disable debug logging
        const DEBUG_ENABLED = false;
        
        // Log function that only outputs to console if debug is enabled
        function log(message) {
            if (DEBUG_ENABLED) {
                console.log(message);
            }
        }
        
        // Error logger - always logs regardless of debug setting
        function logError(message) {
            console.error("[FANCYMENU VIDEO] " + message);
        }
        
        // Ensure all required elements exist
        function ensureElementsExist() {
            // Ensure video container exists
            if (!document.getElementById('videoContainer')) {
                const container = document.createElement('div');
                container.id = 'videoContainer';
                container.style.width = '100%';
                container.style.height = '100%';
                container.style.display = 'flex';
                container.style.justifyContent = 'center';
                container.style.alignItems = 'center';
                container.style.position = 'relative';
                document.body.appendChild(container);
                log("Created missing videoContainer element");
            }
            
            // Ensure video player exists
            if (!document.getElementById('videoPlayer')) {
                const videoElement = document.createElement('video');
                videoElement.id = 'videoPlayer';
                videoElement.setAttribute('playsinline', '');
                videoElement.setAttribute('webkit-playsinline', '');
                document.getElementById('videoContainer').appendChild(videoElement);
                log("Created missing videoPlayer element");
                
                // Setup initial settings for newly created video element
                videoElement.volume = initialVolume;
                videoElement.loop = initialLoop;
                videoElement.setAttribute('controlslist', 'nodownload nofullscreen noremoteplayback');
                videoElement.setAttribute('nocontrols', '');
                videoElement.controls = false;
                videoElement.autoplay = autoPlay;
            }
            
            // Ensure loader exists (but stays hidden)
            if (!document.getElementById('loader')) {
                const loader = document.createElement('div');
                loader.id = 'loader';
                loader.style.position = 'absolute';
                loader.style.top = '50%';
                loader.style.left = '50%';
                loader.style.transform = 'translate(-50%, -50%)';
                loader.style.display = 'none';
                loader.style.visibility = 'hidden';
                loader.style.opacity = '0';
                
                const spinner = document.createElement('div');
                spinner.className = 'spinner';
                spinner.style.display = 'none';
                spinner.style.visibility = 'hidden';
                spinner.style.opacity = '0';
                
                const loaderText = document.createElement('div');
                loaderText.id = 'loaderText';
                loaderText.style.display = 'none';
                loaderText.style.visibility = 'hidden';
                loaderText.style.opacity = '0';
                
                loader.appendChild(spinner);
                loader.appendChild(loaderText);
                document.body.appendChild(loader);
                log("Created missing loader element (hidden)");
            }
            
            return {
                videoContainer: document.getElementById('videoContainer'),
                videoPlayer: document.getElementById('videoPlayer'),
                loader: document.getElementById('loader'),
                loaderText: document.getElementById('loaderText')
            };
        }
        
        // Call function to ensure all elements exist
        const elements = ensureElementsExist();
        const videoContainer = elements.videoContainer;
        const videoPlayer = elements.videoPlayer;
        const loader = elements.loader;
        const loaderText = elements.loaderText;
        
        // Initialize variables
        let videoSource = '';
        let videoBlob = null;
        
        // Parse URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const initialVolume = parseFloat(urlParams.get('volume')) || 1.0;
        const initialLoop = urlParams.get('loop') === 'true';
        const initialFillScreen = urlParams.get('fillScreen') === 'true';
        // 'autoPlay' param means "should this video attempt to play as soon as it's loaded?"
        const wantsAutoplay = urlParams.get('autoPlay') !== 'false'; // Default to true if not specified or not 'false'
        const initialVideoPath = urlParams.get('video') || '';

        videoPlayer.volume = initialVolume;
        videoPlayer.loop = initialLoop;
        videoPlayer.controls = false; // Hide controls by default
        // videoPlayer.autoplay = wantsAutoplay; // We'll handle autoplay more explicitly

        if (initialFillScreen) {
            videoContainer.classList.add('fill-screen');
        }

        // Make sure loader is always hidden
        if (loader) {
            loader.style.display = 'none';
            loader.style.visibility = 'hidden';
            loader.style.opacity = '0';
        }

        window.videoPlayerAPI = {
            currentSettings: {
                volume: initialVolume,
                loop: initialLoop,
                fillScreen: initialFillScreen,
                muted: videoPlayer.muted, // Reflect actual initial muted state (browsers might force mute for autoplay)
                videoLoadedAndReady: false, // True when video can actually start playing
                playRequestPending: wantsAutoplay, // If initially wants autoplay, treat as a pending play request
                currentVideoSrc: initialVideoPath // Store the src for reference
            },

            loadVideo: function(path) {
                log(`API called: loadVideo(${path})`);
                this.currentSettings.currentVideoSrc = path;
                this.currentSettings.videoLoadedAndReady = false;
                // If a new video is loaded, and the original intent was to autoplay,
                // or if a play was requested before this load, keep playRequestPending.
                // Let's assume a new loadVideo implies a new context for autoplay.
                // The caller (Java) can call play() after loadVideo if desired.
                // For now, loadVideo itself won't automatically set playRequestPending unless wantsAutoplay was true from URL.
                // This means if Java calls loadVideo then play, play() will set playRequestPending.

                videoPlayer.pause();
                if (videoPlayer.src) { // Revoke old blob URL if one was used
                    URL.revokeObjectURL(videoPlayer.src);
                }
                videoPlayer.removeAttribute('src');
                videoPlayer.load(); // Important to reset the video element's state
                
                // Use the existing loadVideo (renamed to internalLoadVideo)
                internalLoadVideo(path); 
                return true;
            },

            play: function() {
                log('API called: play()');
                this.currentSettings.playRequestPending = true;
                if (this.currentSettings.videoLoadedAndReady) {
                    log('Video ready, attempting to play immediately.');
                    tryPlayVideo();
                } else {
                    log('Video not ready, play request queued.');
                    // If src is set but not loading, try to kickstart it
                    if (videoPlayer.currentSrc && videoPlayer.readyState < HTMLMediaElement.HAVE_METADATA) {
                        log('Kicking video.load() as src is present but not ready.');
                        videoPlayer.load();
                    }
                }
                return true;
            },

            pause: function() {
                log('API called: pause()');
                this.currentSettings.playRequestPending = false; // Cancel any pending play request
                videoPlayer.pause();
                return true;
            },

            stop: function() {
                log('API called: stop()');
                this.currentSettings.playRequestPending = false;
                videoPlayer.pause();
                videoPlayer.currentTime = 0;
                return true;
            },
            
            togglePlayPause: function() {
                log('API called: togglePlayPause()');
                if (videoPlayer.paused) {
                    this.play();
                } else {
                    this.pause();
                }
                return true;
            },

            setVolume: function(volume) {
                volume = Math.max(0, Math.min(1, volume));
                log(`API called: setVolume(${Math.round(volume * 100)}%)`);
                this.currentSettings.volume = volume;
                videoPlayer.volume = volume;
                return true;
            },
            
            setLoop: function(shouldLoop) {
                log(`API called: setLoop(${shouldLoop})`);
                this.currentSettings.loop = shouldLoop;
                videoPlayer.loop = shouldLoop;
                return true;
            },

            setFillScreen: function(shouldFill) {
                log(`API called: setFillScreen(${shouldFill})`);
                this.currentSettings.fillScreen = shouldFill;
                if (shouldFill) {
                    videoContainer.classList.add('fill-screen');
                } else {
                    videoContainer.classList.remove('fill-screen');
                }
                return true;
            },

            setMuted: function(muted) {
                log(`API called: setMuted(${muted})`);
                this.currentSettings.muted = muted;
                videoPlayer.muted = muted;
                return true;
            },
            
            // isPlaying should reflect videoPlayer.paused directly
            isPlaying: function() {
                return videoPlayer && !videoPlayer.paused && videoPlayer.readyState > HTMLMediaElement.HAVE_CURRENT_DATA;
            },

        // For getters, ensure videoPlayer exists and has meaningful data
            getDuration: function() { 
                try {
                    return videoPlayer && !isNaN(videoPlayer.duration) ? videoPlayer.duration : 0; 
                } catch(e) {
                    logError('Error in getDuration: ' + e.message);
                    return 0;
                }
            },
            getCurrentTime: function() { 
                try {
                    return videoPlayer ? videoPlayer.currentTime : 0; 
                } catch(e) {
                    logError('Error in getCurrentTime: ' + e.message);
                    return 0;
                }
            },
            getVideoWidth: function() { 
                try {
                    return videoPlayer ? videoPlayer.videoWidth : 0; 
                } catch(e) {
                    logError('Error in getVideoWidth: ' + e.message);
                    return 0;
                }
            },
            getVideoHeight: function() { 
                try {
                    return videoPlayer ? videoPlayer.videoHeight : 0; 
                } catch(e) {
                    logError('Error in getVideoHeight: ' + e.message);
                    return 0;
                }
            },

            setCurrentTime: function(time) {
                log(`API called: setCurrentTime(${time})`);
                time = Math.max(0, time);
                if (videoPlayer && videoPlayer.readyState > 0) { // HAVE_NOTHING = 0
                    videoPlayer.currentTime = time;
                } else {
                    log("Warning: Video not ready yet for setCurrentTime, command might be ignored.");
                    // Optionally, queue this if critical, but usually seeking requires some metadata.
                }
                return true;
            }
        };

        function tryPlayVideo() {
            log('Attempting to play video (tryPlayVideo)...');
            if (!videoPlayer.currentSrc) {
                log('tryPlayVideo: No src. Aborting play attempt.');
                // Keep playRequestPending true if it was set
                return;
            }

            const playPromise = videoPlayer.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    log('Video playback started successfully (tryPlayVideo)');
                    window.videoPlayerAPI.currentSettings.playRequestPending = false;
                }).catch(e => {
                    log(`Standard play failed (tryPlayVideo): ${e.message}. Muted: ${videoPlayer.muted}, ReadyState: ${videoPlayer.readyState}`);
                    // Autoplay policies often require muted. Try with muted.
                    if (!videoPlayer.muted) {
                        log('Trying muted playback (tryPlayVideo)...');
                        const originallyMutedByUser = window.videoPlayerAPI.currentSettings.muted;
                        videoPlayer.muted = true; // Force mute for this attempt
                        window.videoPlayerAPI.currentSettings.muted = true; // Reflect this forced mute

                        videoPlayer.play().then(() => {
                            log('Muted playback started successfully (tryPlayVideo)');
                            window.videoPlayerAPI.currentSettings.playRequestPending = false;
                            // If the user didn't intend to mute, try unmuting after a bit.
                            // This is a common pattern to satisfy autoplay-with-sound policies after user interaction.
                            if (!originallyMutedByUser) {
                                setTimeout(() => {
                                    log('Attempting to unmute after successful muted autoplay.');
                                    videoPlayer.muted = false;
                                    window.videoPlayerAPI.currentSettings.muted = false;
                                }, 500);
                            }
                        }).catch(e2 => {
                            logError(`Muted play also failed (tryPlayVideo): ${e2.message}`);
                            // Restore intended muted state if muted play failed
                            videoPlayer.muted = originallyMutedByUser;
                            window.videoPlayerAPI.currentSettings.muted = originallyMutedByUser;
                            // Keep playRequestPending true so that further 'canplay' events might trigger it
                        });
                    } else {
                         // Already muted and failed, keep playRequestPending.
                         log('Play failed while already muted (tryPlayVideo). Keeping request pending.');
                    }
                });
            } else {
                log("video.play() did not return a promise. This browser might be older. Relying on events.");
                // For older browsers/contexts, the 'playing' event will be the confirmation.
                // If it plays, playRequestPending will be cleared by the 'playing' event handler.
            }
        }
        
        // Functions to load files in different ways
        
        // Method 1: Direct src attribute (works for some videos)
        function loadVideoDirectly(path) {
            log(`Loading video directly: ${path}`);
            videoPlayer.src = path;
            
            // Ensure controls are disabled
            videoPlayer.removeAttribute('controls');
            videoPlayer.setAttribute('nocontrols', '');
            videoPlayer.setAttribute('controlslist', 'nodownload nofullscreen noremoteplayback');
            videoPlayer.controls = false;
            
            videoPlayer.load();
        }
        
        // Method 2: XHR + Blob approach (works for local files)
        function loadVideoAsBlob(path) {
            log(`Loading video as blob: ${path}`);
            
            const xhr = new XMLHttpRequest();
            xhr.open('GET', path, true);
            xhr.responseType = 'blob';
            
            xhr.onprogress = function(event) {
                if (event.lengthComputable) {
                    const percentComplete = Math.round((event.loaded / event.total) * 100);
                    log(`Loading progress: ${percentComplete}%`);
                }
            };
            
            xhr.onload = function() {
                if (this.status === 200) {
                    // Release previous blob
                    if (videoBlob) {
                        URL.revokeObjectURL(videoPlayer.src);
                    }
                    
                    // Create blob URL
                    videoBlob = this.response;
                    const blobUrl = URL.createObjectURL(videoBlob);
                    log(`Created blob URL: ${blobUrl}`);
                    
                    // Set video source
                    videoPlayer.src = blobUrl;
                    
                    // Ensure controls are disabled
                    videoPlayer.removeAttribute('controls');
                    videoPlayer.setAttribute('nocontrols', '');
                    videoPlayer.setAttribute('controlslist', 'nodownload nofullscreen noremoteplayback');
                    videoPlayer.controls = false;
                    
                    videoPlayer.load();
                    // No direct play here, will let events handle it
                } else {
                    logError(`XHR failed with status: ${this.status}`);
                }
            };
            
            xhr.onerror = function() {
                logError('XHR network error when loading video');
                
                // Try direct loading as fallback
                log('Trying direct loading as fallback');
                loadVideoDirectly(path);
            };
            
            xhr.send();
        }
        
        // Main load function that decides which method to use
        function internalLoadVideo(path) {
            if (!path) {
                logError('No video path provided');
                return;
            }
            
            // Store the current source
            videoSource = path;
            log(`Loading video from path: ${path}`);
            
            // For local file paths, use the blob approach
            if (path.startsWith('file://')) {
                loadVideoAsBlob(path);
            } else {
                // For other URLs, try direct loading
                loadVideoDirectly(path);
                
                // If direct loading doesn't work after a short time, try blob approach
                setTimeout(function() {
                    if (!videoPlayer.duration && videoPlayer.readyState < 2) {
                        log('Direct loading not working, trying blob approach');
                        loadVideoAsBlob(path);
                    }
                }, 2000);
            }
        }

        videoPlayer.addEventListener('loadedmetadata', function() {
            log(`Video metadata loaded: ${videoPlayer.videoWidth}x${videoPlayer.videoHeight}, duration: ${videoPlayer.duration}, readyState: ${videoPlayer.readyState}`);
            applyStoredSettings(); // Apply volume, loop etc. as they don't depend on play readiness
        });

        videoPlayer.addEventListener('canplay', function() {
            log(`Video can play. ReadyState=${videoPlayer.readyState}`);
            // Consider ready if we have at least HAVE_FUTURE_DATA, but HAVE_ENOUGH_DATA is safer.
            if (videoPlayer.readyState >= HTMLMediaElement.HAVE_FUTURE_DATA) { // HAVE_FUTURE_DATA = 3, HAVE_ENOUGH_DATA = 4
                window.videoPlayerAPI.currentSettings.videoLoadedAndReady = true;
                log('Set videoLoadedAndReady = true (on canplay)');
            }
            applyStoredSettings(); 

            if (window.videoPlayerAPI.currentSettings.playRequestPending && window.videoPlayerAPI.currentSettings.videoLoadedAndReady) {
                log('Attempting play due to pending request (on canplay).');
                tryPlayVideo();
            }
        });
        
        videoPlayer.addEventListener('canplaythrough', function() {
            log(`Video can play through. ReadyState=${videoPlayer.readyState}`);
            window.videoPlayerAPI.currentSettings.videoLoadedAndReady = true; // Definitely ready
            log('Set videoLoadedAndReady = true (on canplaythrough)');
            
            if (window.videoPlayerAPI.currentSettings.playRequestPending) {
                log('Attempting play due to pending request (on canplaythrough).');
                tryPlayVideo();
            }
        });

        videoPlayer.addEventListener('playing', function() {
            log('Video event: playing. ReadyState=' + videoPlayer.readyState);
            window.videoPlayerAPI.currentSettings.playRequestPending = false; // Clear flag as it's now playing
        });

        videoPlayer.addEventListener('pause', function() {
            log('Video event: pause');
            // Don't automatically clear playRequestPending here, as a pause could be transient (buffering)
            // or user-initiated. The API's pause() already clears it.
        });
        
        videoPlayer.addEventListener('waiting', function() {
            log('Video buffering...');
            // No need to show loading indicator
        });
        
        videoPlayer.addEventListener('ended', function() {
            log('Video ended');
            // Update the playing state in the API unless looping
            if (window.videoPlayerAPI && !videoPlayer.loop) {
                window.videoPlayerAPI.currentSettings.playRequestPending = false;
            }
        });
        
        videoPlayer.addEventListener('error', function(e) {
            // Always log the error details
            let errorMessage = "Unknown error";
            
            if (videoPlayer.error) {
                switch(videoPlayer.error.code) {
                    case 1: errorMessage = "Video loading aborted"; break;
                    case 2: errorMessage = "Network error"; break;
                    case 3: errorMessage = "Video decoding failed"; break;
                    case 4: errorMessage = "Video format not supported"; break;
                }
                
                errorMessage += ` (${videoPlayer.error.code})`;
            }
            
            logError(`Video error: ${errorMessage}`);
            
            // Try to provide more detailed error info
            const videoSrc = videoPlayer.currentSrc || videoSource || "(unknown)";
            logError(`Source: ${videoSrc}`);
        });

        function applyStoredSettings() {
            log(`Applying settings: Vol=${window.videoPlayerAPI.currentSettings.volume}, Loop=${window.videoPlayerAPI.currentSettings.loop}, Muted=${window.videoPlayerAPI.currentSettings.muted}`);
            videoPlayer.volume = window.videoPlayerAPI.currentSettings.volume;
            videoPlayer.loop = window.videoPlayerAPI.currentSettings.loop;
            videoPlayer.muted = window.videoPlayerAPI.currentSettings.muted; // Apply JS-side muted state
            if (window.videoPlayerAPI.currentSettings.fillScreen) {
                videoContainer.classList.add('fill-screen');
            } else {
                videoContainer.classList.remove('fill-screen');
            }
        }
        
        // Initial load if path provided in URL
        if (initialVideoPath) {
            log(`Initial video from URL param: ${initialVideoPath}. Wants autoplay: ${wantsAutoplay}`);
            // `wantsAutoplay` already set `playRequestPending` in currentSettings initialization.
            window.videoPlayerAPI.loadVideo(initialVideoPath); // Use API to load
        }
        
        log('FancyMenu Video Player HTML initialized.');
    </script>
</body>
</html>